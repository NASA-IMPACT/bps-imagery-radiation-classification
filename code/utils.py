import glob

import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns

from config import N_ROWS, N_COLS, TIME_DICT, DATA_BASE_PATH, DOSEDICT


def get_data_and_count(verbose = False):
    """
    Creates a dictionary with file path after discarding 0Gy plates using the DOSEDICT
    provided in the dataset.
    :param verbose: (Bool): If True: Prints stats of data in each class
    :return: (dict) : {radiation:[file paths]}
             (dict) : {radiation:{time_interval:[file paths]}}
    """
    data_dict = {}
    time_dict = {}
    radiation_types = glob.glob(f"{DATA_BASE_PATH}*")
    for radiation in radiation_types:
        filtered_files = []
        rad_time_dict = {val: [] for val in TIME_DICT.values()}
        data_dict[radiation] = glob.glob(f'{radiation}/*tif')
        for file in data_dict[radiation]:
            filename = file.replace(f"{radiation}/", "")
            if filename[:4] not in DOSEDICT:
                filtered_files.append(f"{radiation}/{filename}")
                rad_time_dict[TIME_DICT[filename[:4]]].append(f"{radiation}/{filename}")
        data_dict[radiation] = filtered_files
        if verbose:
            print(f"Number of files in {radiation}, time interval wise: ")
            print({val:len(rad_time_dict[val]) for val in rad_time_dict})
        time_dict[radiation] = rad_time_dict

    if verbose:
        print("Number of samples for each radiation:")
        print({radiation:len(data_dict[radiation]) for radiation in data_dict})

    return data_dict, time_dict


def plot_confusion_matrix(cnfsn_matrix, time_interval):
    """
    Plots the confusion matrix for a prediction
    :param cnfsn_matrix: confusion matrix generated by sklearn confusion_matrix()
    :param time_interval: time interval at which the data was sampled
    :return: None
    """
    print(f"Confusion matrix: {cnfsn_matrix}")
    class_names = ['Fe','X-Ray']
    df_cm = pd.DataFrame(cnfsn_matrix, class_names, class_names)
    fig = plt.figure(figsize=(10, 8))
    sns.heatmap(df_cm, annot=True, fmt="d", cmap='BuGn')
    plt.xlabel(f"prediction")
    plt.ylabel(f"label (ground truth)")
    if time_interval is not None:
        fig.savefig(f'confusion_matrix_time{time_interval}.png')
    else:
        fig.savefig(f'confusion_matrix_time.png')

def compute_padding(src_shape):
    """
    Computes the padding required to make uniform image dimension across the dataset.
    ToDo: compute N_ROWS and N_COLS from the data, instead of using config file.
    :param src_shape: (numpy_arr) : shape of a sample image
    :return: (tuple) :  ((req. padding before row,req. padding after row),
                        (req. padding before column,req. padding after column))
    """

    row_padding = N_ROWS - src_shape[0]
    before_row = int(row_padding/2)
    after_row = row_padding - before_row

    col_padding = N_COLS - src_shape[1]
    before_col = int(col_padding/2)
    after_col = col_padding - before_col

    return ((before_row, after_row),(before_col,after_col))


def restructure_time_data_dict(time_data_dict):
    """
    Converts the time_data_dict {radiation:{time_interval:[file paths]}} to
    {time_interval:{radiation:{file paths}}}
    :param time_data_dict: (dictionary) {radiation:{time_interval:[file paths]}}
    :return: (dictionary) : {time_interval:{radiation:{file paths}}}
    """
    restructured_data_dict = {}
    for radiation, time_dict in time_data_dict.items():
        for time_val, file_list in time_dict.items():
            if time_val not in restructured_data_dict.keys():
                restructured_data_dict[time_val] = {radiation:file_list}
                continue
            restructured_data_dict[time_val] = {**restructured_data_dict[time_val],
                                       **{radiation:file_list}}
    return restructured_data_dict

def main():
    pass

if __name__ == "__main__":
    main()
