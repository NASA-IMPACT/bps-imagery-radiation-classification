import glob
import os

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns
import torch
from captum.attr import visualization as viz

from config import N_ROWS, N_COLS, TIME_DICT, DATA_BASE_PATH, ZERODOSE, CNN_CONFUSION, GRADCAM_PATH


def visualize_gradcam(attr, img, batch_idx, labels, pred_labels):
    """
    Visualization of the gradcam on input data
    :param attr: Grad cam attributes
    :param img: Input image
    :param batch_idx: Batch number - used to label the result image
    :param labels: Ground truth of the image
    :param pred_labels: Prediction label for the image
    :return: None
    """
    attr = np.transpose(attr.squeeze().cpu().detach().numpy(), (1, 2, 0))
    img = np.transpose(img.squeeze().cpu().detach().numpy(), (1, 2, 0))

    for idx in range(img.shape[2]):
        attr_slice = attr[:, :, idx].reshape(attr.shape[0], attr.shape[1], 1)
        img_slice = img[:, :, idx].reshape(img.shape[0], img.shape[1], 1)
        vis_types = ["blended_heat_map", "original_image"]
        vis_signs = ["positive", "all"]
        # if sum(x > 0 for x in np.unique(attr_slice)) == 0:
        #     print(idx)
        #     continue
        fig, _ = viz.visualize_image_attr_multiple(
            attr_slice,
            img_slice,
            vis_types,
            vis_signs,
            ["GradCam", "Input image"],
            show_colorbar=True,
            use_pyplot=False,
        )
        if not os.path.isdir(GRADCAM_PATH):
            print("GradCAM result directory not found !!!")
            print("Creating the directory")
            os.makedirs(GRADCAM_PATH)

        fig.savefig(
            f'{GRADCAM_PATH}/gradcam_{batch_idx}_{idx}_label{labels[idx].item()}_pre'
            f'd{pred_labels[idx].item()}.png'
        )


def compute_correct_pred_torch(pred, act_labels):
    """
    Computes the number of correct predictions
    :param pred:(torch tensor) predicted label
    :param act_labels: (torch tensor) actual label
    :return: total number of correct predictions
    """
    # correct = 0
    _, predicted_idx = torch.max(pred.data, 1)
    _, label_idx = torch.max(act_labels.data, 1)
    correct = (predicted_idx == label_idx).sum()
    return correct.item()


def plot_data(trainloss, valloss, filename_plot):
    fig = plt.figure(figsize=(10, 8))
    plt.plot([i for i in range(len(trainloss))], trainloss, 'r', label="Training")
    plt.plot([i for i in range(len(valloss))], valloss, 'g', label="Validation ")
    plt.legend()
    fig.savefig(filename_plot)


def get_data_and_count(verbose=False):
    """
    Creates a dictionary with file path after discarding 0Gy plates using the DOSEDICT
    provided in the dataset.
    :param verbose: (Bool): If True: Prints stats of data in each class
    :return: (dict) : {radiation:[file paths]}
             (dict) : {radiation:{time_interval:[file paths]}}
    """
    data_dict = {}
    time_dict = {}
    radiation_types = glob.glob(f"{DATA_BASE_PATH}*")
    for radiation in radiation_types:
        filtered_files = []
        rad_time_dict = {val: [] for val in TIME_DICT.values()}
        data_dict[radiation] = glob.glob(f'{radiation}/*tif')
        for file in data_dict[radiation]:
            filename = file.replace(f"{radiation}/", "")
            if filename[:4] not in ZERODOSE:
                filtered_files.append(f"{radiation}/{filename}")
                rad_time_dict[TIME_DICT[filename[:4]]].append(f"{radiation}/{filename}")
        data_dict[radiation] = filtered_files
        if verbose:
            print(f"Number of files in {radiation}, time interval wise: ")
            print({val: len(rad_time_dict[val]) for val in rad_time_dict})
        time_dict[radiation] = rad_time_dict

    if verbose:
        print("Number of samples for each radiation:")
        print({radiation: len(data_dict[radiation]) for radiation in data_dict})

    return data_dict, time_dict


def plot_confusion_matrix(cnfsn_matrix, time_interval=None):
    """
    Plots the confusion matrix for a prediction
    :param cnfsn_matrix: confusion matrix generated by sklearn confusion_matrix()
    :param time_interval: time interval at which the data was sampled
    :return: None
    """
    print(f"Confusion matrix: {cnfsn_matrix}")
    class_names = ['Fe', 'X-Ray']
    df_cm = pd.DataFrame(cnfsn_matrix, class_names, class_names)
    fig = plt.figure(figsize=(10, 8))
    sns.heatmap(df_cm, annot=True, fmt="d", cmap='BuGn')
    plt.xlabel("prediction")
    plt.ylabel("label (ground truth)")
    if time_interval is not None:
        fig.savefig(f'confusion_matrix_time{time_interval}.png')
    else:
        fig.savefig(CNN_CONFUSION)


def compute_padding(src_shape):
    """
    Computes the padding required to make uniform image dimension across the dataset.
    :param src_shape: (numpy_arr) : shape of a sample image
    :return: (tuple) :  ((req. padding before row,req. padding after row),
                        (req. padding before column,req. padding after column))
    """

    row_padding = N_ROWS - src_shape[0]
    before_row = int(row_padding / 2)
    after_row = row_padding - before_row

    col_padding = N_COLS - src_shape[1]
    before_col = int(col_padding / 2)
    after_col = col_padding - before_col

    return ((before_row, after_row), (before_col, after_col))


def restructure_time_data_dict(time_data_dict):
    """
    Converts the time_data_dict {radiation:{time_interval:[file paths]}} to
    {time_interval:{radiation:{file paths}}}
    :param time_data_dict: (dictionary) {radiation:{time_interval:[file paths]}}
    :return: (dictionary) : {time_interval:{radiation:{file paths}}}
    """
    restructured_data_dict = {}
    for radiation, time_dict in time_data_dict.items():
        for time_val, file_list in time_dict.items():
            if time_val not in restructured_data_dict.keys():
                restructured_data_dict[time_val] = {radiation: file_list}
                continue
            restructured_data_dict[time_val] = {
                **restructured_data_dict[time_val],
                **{radiation: file_list},
            }

    return restructured_data_dict


def main():
    pass


if __name__ == "__main__":
    main()
